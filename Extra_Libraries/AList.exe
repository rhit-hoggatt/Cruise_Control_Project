# 1 "C:\\Users\\johnw\\Documents\\Arduino\\Git_Repos\\Cruise_Control_Project\\Extra_Libraries\\AList.cpp"
# 1 "C:\\Users\\johnw\\Documents\\Arduino\\Git_Repos\\Cruise_Control_Project\\Extra_Libraries//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "C:\\Users\\johnw\\Documents\\Arduino\\Git_Repos\\Cruise_Control_Project\\Extra_Libraries\\AList.cpp"
# 17 "C:\\Users\\johnw\\Documents\\Arduino\\Git_Repos\\Cruise_Control_Project\\Extra_Libraries\\AList.cpp"
template <typename T>
class CDLLI {


    CDLLI<T>* _next;
    CDLLI<T>* _prev;
 public:

    static CDLLI<T>* head;
    static CDLLI<T>* tail;


    explicit CDLLI(bool toFront = false) {
        if(toFront) {
            _prev = nullptr;
            if(!tail) tail = this;
            if(head) head->_prev = this;
            _next = head;
            head = this;
        } else {
            _prev = tail;
            if(!head) head = this;
            if(tail) tail->_next = this;
            tail = this;
            _next = nullptr;
        }
    }

    virtual ~CDLLI() {
        if(_prev) _prev->_next = _next;
        if(_next) _next->_prev = _prev;
        if(tail == this) tail = _prev;
        if(head == this) head = _next;
    }


    T* next(bool wrap = false) {
        if(!_next && wrap) return (T*) head;
        return ((T*) _next);
    }
    T* previous(bool wrap = false) {
        if(!_prev && wrap) return (T*) tail;
        return ((T*) _prev);
    }

    static T& getHead() {
        return *(T*)head;
    }

    static T& getTail() {
        return *(T*)tail;
    }

    class Iterator {
        CDLLI<T>* current;

     public:
        explicit Iterator(CDLLI<T>* CDLLI) : current(CDLLI) {}

        Iterator& operator++() {
            current = current->_next;
            return *this;
        }

        bool operator!=(const Iterator& other) const {
            return current != other.current;
        }

        T& operator*(){
            return *((T*) current);
        }
    };

    Iterator begin() {
        return Iterator(head);
    }

    Iterator end() {
        return Iterator(nullptr);
    }


    void swap(CDLLI<T>& other) {
        head = (head == this ? &other :
                       (head == &other ? this : head));
        tail = (tail == this ? &other :
                       (tail == &other ? this : tail));

        auto swap = _prev;
        _prev = other._prev;
        other._prev = swap;

        swap = _next;
        _next = other._next;
        other._next = swap;

        if(_prev) _prev->_next = this;
        if(_next) _next->_prev = this;
        if(other._prev) other._prev->_next = &other;
        if(other._next) other._next->_prev = &other;
    }
};

template <typename T>
CDLLI<T>* CDLLI<T>::head = nullptr;
template <typename T>
CDLLI<T>* CDLLI<T>::tail = nullptr;







template <typename T>
class AList{


    static void main(){
        int i 0;
    }

};
